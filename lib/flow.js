"use strict";

var t = require("./..");

var stringifyValidator = require("./stringifyValidator");

var toFunctionName = require("./toFunctionName");

var NODE_PREFIX = "BabelNode";
var code = "// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/flow.js for script used.\n\ndeclare class ".concat(NODE_PREFIX, "Comment {\n  value: string;\n  start: number;\n  end: number;\n  loc: ").concat(NODE_PREFIX, "SourceLocation;\n}\n\ndeclare class ").concat(NODE_PREFIX, "CommentBlock extends ").concat(NODE_PREFIX, "Comment {\n  type: \"CommentBlock\";\n}\n\ndeclare class ").concat(NODE_PREFIX, "CommentLine extends ").concat(NODE_PREFIX, "Comment {\n  type: \"CommentLine\";\n}\n\ndeclare class ").concat(NODE_PREFIX, "SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ndeclare class ").concat(NODE_PREFIX, " {\n  leadingComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  innerComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  trailingComments?: Array<").concat(NODE_PREFIX, "Comment>;\n  start: ?number;\n  end: ?number;\n  loc: ?").concat(NODE_PREFIX, "SourceLocation;\n}\n\n"); //

var lines = [];

var _loop = function _loop(type) {
  var fields = t.NODE_FIELDS[type];
  var struct = ['type: "' + type + '";'];
  var args = [];
  Object.keys(t.NODE_FIELDS[type]).sort(function (fieldA, fieldB) {
    var indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    var indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  }).forEach(function (fieldName) {
    var field = fields[fieldName];
    var suffix = "";
    if (field.optional || field["default"] != null) suffix += "?";
    var typeAnnotation = "any";
    var validate = field.validate;

    if (validate) {
      typeAnnotation = stringifyValidator(validate, NODE_PREFIX);
    }

    if (typeAnnotation) {
      suffix += ": " + typeAnnotation;
    }

    args.push(t.toBindingIdentifierName(fieldName) + suffix);

    if (t.isValidIdentifier(fieldName)) {
      struct.push(fieldName + suffix + ";");
    }
  });
  code += "declare class ".concat(NODE_PREFIX).concat(type, " extends ").concat(NODE_PREFIX, " {\n  ").concat(struct.join("\n  ").trim(), "\n}\n\n"); // Flow chokes on super() and import() :/

  if (type !== "Super" && type !== "Import") {
    lines.push("declare function ".concat(toFunctionName(type), "(").concat(args.join(", "), "): ").concat(NODE_PREFIX).concat(type, ";"));
  }
};

for (var type in t.NODE_FIELDS) {
  _loop(type);
}

for (var i = 0; i < t.TYPES.length; i++) {
  var decl = "declare function is".concat(t.TYPES[i], "(node: Object, opts?: ?Object): boolean");

  if (t.NODE_FIELDS[t.TYPES[i]]) {
    decl += " %checks (node instanceof ".concat(NODE_PREFIX).concat(t.TYPES[i], ")");
  }

  lines.push(decl);
}

lines.push("declare function validate(n: BabelNode, key: string, value: mixed): void;", "declare function clone<T>(n: T): T;", "declare function cloneDeep<T>(n: T): T;", "declare function removeProperties<T>(n: T, opts: ?{}): void;", "declare function removePropertiesDeep<T>(n: T, opts: ?{}): T;", "declare type TraversalAncestors = Array<{\n    node: BabelNode,\n    key: string,\n    index?: number,\n  }>;\n  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;\n  declare type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };".replace(/(^|\n) {2}/g, "$1"), // eslint-disable-next-line
"declare function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;");

for (var type in t.FLIPPED_ALIAS_KEYS) {
  var types = t.FLIPPED_ALIAS_KEYS[type];
  code += "type ".concat(NODE_PREFIX).concat(type, " = ").concat(types.map(function (type) {
    return "".concat(NODE_PREFIX).concat(type);
  }).join(" | "), ";\n");
}

code += "\ndeclare module \"@babel/types\" {\n  ".concat(lines.join("\n").replace(/\n/g, "\n  ").trim(), "\n}\n"); //

process.stdout.write(code);