"use strict";

var t = require("./..");

var stringifyValidator = require("./stringifyValidator");

var toFunctionName = require("./toFunctionName");

var code = "// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/typescript.js for script used.\n\ninterface BaseComment {\n  value: string;\n  start: number;\n  end: number;\n  loc: SourceLocation;\n  type: \"CommentBlock\" | \"CommentLine\";\n}\n\nexport interface CommentBlock extends BaseComment {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends BaseComment {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\nexport interface SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ninterface BaseNode {\n  leadingComments: ReadonlyArray<Comment> | null;\n  innerComments: ReadonlyArray<Comment> | null;\n  trailingComments: ReadonlyArray<Comment> | null;\n  start: number | null;\n  end: number | null;\n  loc: SourceLocation | null;\n  type: Node[\"type\"];\n}\n\nexport type Node = ".concat(t.TYPES.sort().join(" | "), ";\n\n"); //

var lines = [];

var _loop = function _loop(type) {
  var fields = t.NODE_FIELDS[type];
  var fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);
  var struct = ['type: "' + type + '";'];
  var args = [];
  fieldNames.forEach(function (fieldName) {
    var field = fields[fieldName];
    var typeAnnotation = stringifyValidator(field.validate, "");

    if (isNullable(field) && !hasDefault(field)) {
      typeAnnotation += " | null";
    }

    if (areAllRemainingFieldsNullable(fieldName, fieldNames, fields)) {
      args.push("".concat(t.toBindingIdentifierName(fieldName)).concat(isNullable(field) ? "?:" : ":", " ").concat(typeAnnotation));
    } else {
      args.push("".concat(t.toBindingIdentifierName(fieldName), ": ").concat(typeAnnotation).concat(isNullable(field) ? " | undefined" : ""));
    }

    var alphaNumeric = /^\w+$/;

    if (t.isValidIdentifier(fieldName) || alphaNumeric.test(fieldName)) {
      struct.push("".concat(fieldName, ": ").concat(typeAnnotation, ";"));
    } else {
      struct.push("\"".concat(fieldName, "\": ").concat(typeAnnotation, ";"));
    }
  });
  code += "export interface ".concat(type, " extends BaseNode {\n  ").concat(struct.join("\n  ").trim(), "\n}\n\n"); // super and import are reserved words in JavaScript

  if (type !== "Super" && type !== "Import") {
    lines.push("export function ".concat(toFunctionName(type), "(").concat(args.join(", "), "): ").concat(type, ";"));
  }
};

for (var type in t.NODE_FIELDS) {
  _loop(type);
}

for (var i = 0; i < t.TYPES.length; i++) {
  var decl = "export function is".concat(t.TYPES[i], "(node: object, opts?: object | null): ");

  if (t.NODE_FIELDS[t.TYPES[i]]) {
    decl += "node is ".concat(t.TYPES[i], ";");
  } else if (t.FLIPPED_ALIAS_KEYS[t.TYPES[i]]) {
    decl += "node is ".concat(t.TYPES[i], ";");
  } else {
    decl += "boolean;";
  }

  lines.push(decl);
}

lines.push("export function validate(n: Node, key: string, value: any): void;", "export function clone<T extends Node>(n: T): T;", "export function cloneDeep<T extends Node>(n: T): T;", "export function removeProperties(\n  n: Node,\n  opts?: { preserveComments: boolean } | null\n): void;", "export function removePropertiesDeep<T extends Node>(\n  n: T,\n  opts?: { preserveComments: boolean } | null\n): T;", "export type TraversalAncestors = ReadonlyArray<{\n    node: Node,\n    key: string,\n    index?: number,\n  }>;\n  export type TraversalHandler<T> = (node: Node, parent: TraversalAncestors, type: T) => void;\n  export type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };".replace(/(^|\n) {2}/g, "$1"), // eslint-disable-next-line
"export function traverse<T>(n: Node, h: TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;");

for (var type in t.DEPRECATED_KEYS) {
  code += "/**\n * @deprecated Use `".concat(t.DEPRECATED_KEYS[type], "`\n */\nexport type ").concat(type, " = ").concat(t.DEPRECATED_KEYS[type], ";\n\n");
}

for (var _type in t.FLIPPED_ALIAS_KEYS) {
  var types = t.FLIPPED_ALIAS_KEYS[_type];
  code += "export type ".concat(_type, " = ").concat(types.map(function (type) {
    return "".concat(type);
  }).join(" | "), ";\n");
}

code += "\n";
code += "export interface Aliases {\n";

for (var _type2 in t.FLIPPED_ALIAS_KEYS) {
  code += "  ".concat(_type2, ": ").concat(_type2, ";\n");
}

code += "}\n\n";
code += lines.join("\n") + "\n"; //

process.stdout.write(code); //

function areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {
  var index = fieldNames.indexOf(fieldName);
  return fieldNames.slice(index).every(function (_) {
    return isNullable(fields[_]);
  });
}

function hasDefault(field) {
  return field["default"] != null;
}

function isNullable(field) {
  return field.optional || hasDefault(field);
}

function sortFieldNames(fields, type) {
  return fields.sort(function (fieldA, fieldB) {
    var indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    var indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
}